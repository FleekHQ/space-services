/* Generated by `npm run build`, do not edit! */

"use strict"

var privateClassElements = require("../private-class-elements")

module.exports = function(Parser) {
  var ExtendedParser = privateClassElements(Parser)

  var acorn = Parser.acorn || require("acorn")
  var tt = acorn.tokTypes

  return /*@__PURE__*/(function (ExtendedParser) {
    function anonymous () {
      ExtendedParser.apply(this, arguments);
    }

    if ( ExtendedParser ) anonymous.__proto__ = ExtendedParser;
    anonymous.prototype = Object.create( ExtendedParser && ExtendedParser.prototype );
    anonymous.prototype.constructor = anonymous;

    anonymous.prototype._maybeParseFieldValue = function _maybeParseFieldValue (field) {
      if (this.eat(tt.eq)) {
        var oldInFieldValue = this._inStaticFieldScope
        this._inStaticFieldScope = this.currentThisScope()
        field.value = this.parseExpression()
        this._inStaticFieldScope = oldInFieldValue
      } else { field.value = null }
    };

    // Parse fields
    anonymous.prototype.parseClassElement = function parseClassElement (_constructorAllowsSuper) {
      if (this.options.ecmaVersion < 8 || !this.isContextual("static")) {
        return ExtendedParser.prototype.parseClassElement.apply(this, arguments)
      }

      var branch = this._branch()
      branch.next()
      if ([tt.name, tt.bracketL, tt.string, tt.num, this.privateNameToken].indexOf(branch.type) == -1) {
        return ExtendedParser.prototype.parseClassElement.apply(this, arguments)
      }
      if (branch.type == tt.bracketL) {
        var count = 0
        do {
          if (branch.eat(tt.bracketL)) { ++count }
          else if (branch.eat(tt.bracketR)) { --count }
          else { branch.next() }
        } while (count > 0)
      } else { branch.next() }
      if (branch.type != tt.eq && !branch.canInsertSemicolon() && branch.type != tt.semi) {
        return ExtendedParser.prototype.parseClassElement.apply(this, arguments)
      }

      var node = this.startNode()
      node.static = this.eatContextual("static")
      if (this.type == this.privateNameToken) {
        this.parsePrivateClassElementName(node)
      } else {
        this.parsePropertyName(node)
      }
      if ((node.key.type === "Identifier" && node.key.name === "constructor") ||
          (node.key.type === "Literal" && !node.computed && node.key.value === "constructor")) {
        this.raise(node.key.start, "Classes may not have a field called constructor")
      }
      if ((node.key.name || node.key.value) === "prototype" && !node.computed) {
        this.raise(node.key.start, "Classes may not have a static property named prototype")
      }

      this._maybeParseFieldValue(node)
      this.finishNode(node, "FieldDefinition")
      this.semicolon()
      return node
    };

    // Parse private static methods
    anonymous.prototype.parsePropertyName = function parsePropertyName (prop) {
      if (prop.static && this.type == this.privateNameToken) {
        this.parsePrivateClassElementName(prop)
      } else {
        ExtendedParser.prototype.parsePropertyName.call(this, prop)
      }
    };

    // Prohibit arguments in class field initializers
    anonymous.prototype.parseIdent = function parseIdent (liberal, isBinding) {
      var ident = ExtendedParser.prototype.parseIdent.call(this, liberal, isBinding)
      if (this._inStaticFieldScope && this.currentThisScope() === this._inStaticFieldScope && ident.name == "arguments") {
        this.raise(ident.start, "A static class field initializer may not contain arguments")
      }
      return ident
    };

    return anonymous;
  }(ExtendedParser))
}
