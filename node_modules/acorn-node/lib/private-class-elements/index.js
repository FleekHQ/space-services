/* Generated by `npm run build`, do not edit! */

"use strict"

var getPrototype = Object.getPrototypeOf || (function (o) { return o.__proto__; })

var getAcorn = function (Parser) {
  if (Parser.acorn) { return Parser.acorn }

  var acorn = require("acorn")

  if (acorn.version.indexOf("6.") != 0 && acorn.version.indexOf("6.0.") == 0 && acorn.version.indexOf("7.") != 0) {
    throw new Error(("acorn-private-class-elements requires acorn@^6.1.0 or acorn@7.0.0, not " + (acorn.version)))
  }

  // Make sure `Parser` comes from the same acorn as we `require`d,
  // otherwise the comparisons fail.
  for (var cur = Parser; cur && cur !== acorn.Parser; cur = getPrototype(cur)) {
    if (cur !== acorn.Parser) {
      throw new Error("acorn-private-class-elements does not support mixing different acorn copies")
    }
  }
  return acorn
}

module.exports = function(Parser) {
  // Only load this plugin once.
  if (Parser.prototype.parsePrivateName) {
    return Parser
  }

  var acorn = getAcorn(Parser)

  Parser = /*@__PURE__*/(function (Parser) {
    function Parser_ () {
      Parser.apply(this, arguments);
    }

    if ( Parser ) Parser_.__proto__ = Parser;
    Parser_.prototype = Object.create( Parser && Parser.prototype );
    Parser_.prototype.constructor = Parser_;

    Parser_.prototype._branch = function _branch () {
      this.__branch = this.__branch || new Parser_({ecmaVersion: this.options.ecmaVersion}, this.input)
      this.__branch.end = this.end
      this.__branch.pos = this.pos
      this.__branch.type = this.type
      this.__branch.value = this.value
      this.__branch.containsEsc = this.containsEsc
      return this.__branch
    };

    Parser_.prototype.parsePrivateClassElementName = function parsePrivateClassElementName (element) {
      element.computed = false
      element.key = this.parsePrivateName()
      if (element.key.name == "constructor") { this.raise(element.key.start, "Classes may not have a private element named constructor") }
      var accept = {get: "set", set: "get"}[element.kind]
      var privateBoundNames = this._privateBoundNames
      if (Object.prototype.hasOwnProperty.call(privateBoundNames, element.key.name) && privateBoundNames[element.key.name] !== accept) {
        this.raise(element.start, "Duplicate private element")
      }
      privateBoundNames[element.key.name] = element.kind || true
      delete this._unresolvedPrivateNames[element.key.name]
      return element.key
    };

    Parser_.prototype.parsePrivateName = function parsePrivateName () {
      var node = this.startNode()
      node.name = this.value
      this.next()
      this.finishNode(node, "PrivateName")
      if (this.options.allowReserved == "never") { this.checkUnreserved(node) }
      return node
    };

    // Parse # token
    Parser_.prototype.getTokenFromCode = function getTokenFromCode (code) {
      if (code === 35) {
        ++this.pos
        var word = this.readWord1()
        return this.finishToken(this.privateNameToken, word)
      }
      return Parser.prototype.getTokenFromCode.call(this, code)
    };

    // Manage stacks and check for undeclared private names
    Parser_.prototype.parseClass = function parseClass (node, isStatement) {
      var oldOuterPrivateBoundNames = this._outerPrivateBoundNames
      this._outerPrivateBoundNames = this._privateBoundNames
      this._privateBoundNames = Object.create(this._privateBoundNames || null)
      var oldOuterUnresolvedPrivateNames = this._outerUnresolvedPrivateNames
      this._outerUnresolvedPrivateNames = this._unresolvedPrivateNames
      this._unresolvedPrivateNames = Object.create(null)

      var _return = Parser.prototype.parseClass.call(this, node, isStatement)

      var unresolvedPrivateNames = this._unresolvedPrivateNames
      this._privateBoundNames = this._outerPrivateBoundNames
      this._outerPrivateBoundNames = oldOuterPrivateBoundNames
      this._unresolvedPrivateNames = this._outerUnresolvedPrivateNames
      this._outerUnresolvedPrivateNames = oldOuterUnresolvedPrivateNames
      if (!this._unresolvedPrivateNames) {
        var names = Object.keys(unresolvedPrivateNames)
        if (names.length) {
          names.sort(function (n1, n2) { return unresolvedPrivateNames[n1] - unresolvedPrivateNames[n2]; })
          this.raise(unresolvedPrivateNames[names[0]], "Usage of undeclared private name")
        }
      } else { Object.assign(this._unresolvedPrivateNames, unresolvedPrivateNames) }
      return _return
    };

    // Class heritage is evaluated with outer private environment
    Parser_.prototype.parseClassSuper = function parseClassSuper (node) {
      var privateBoundNames = this._privateBoundNames
      this._privateBoundNames = this._outerPrivateBoundNames
      var unresolvedPrivateNames = this._unresolvedPrivateNames
      this._unresolvedPrivateNames = this._outerUnresolvedPrivateNames
      var _return = Parser.prototype.parseClassSuper.call(this, node)
      this._privateBoundNames = privateBoundNames
      this._unresolvedPrivateNames = unresolvedPrivateNames
      return _return
    };

    // Parse private element access
    Parser_.prototype.parseSubscript = function parseSubscript (base, startPos, startLoc, noCalls, maybeAsyncArrow) {
      if (!this.eat(acorn.tokTypes.dot)) {
        return Parser.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, maybeAsyncArrow)
      }
      var node = this.startNodeAt(startPos, startLoc)
      node.object = base
      node.computed = false
      if (this.type == this.privateNameToken) {
        if (base.type == "Super") {
          this.raise(this.start, "Cannot access private element on super")
        }
        node.property = this.parsePrivateName()
        if (!this._privateBoundNames || !this._privateBoundNames[node.property.name]) {
          if (!this._unresolvedPrivateNames) {
            this.raise(node.property.start, "Usage of undeclared private name")
          }
          this._unresolvedPrivateNames[node.property.name] = node.property.start
        }
      } else {
        node.property = this.parseIdent(true)
      }
      return this.finishNode(node, "MemberExpression")
    };

    // Prohibit delete of private class elements
    Parser_.prototype.parseMaybeUnary = function parseMaybeUnary (refDestructuringErrors, sawUnary) {
      var _return = Parser.prototype.parseMaybeUnary.call(this, refDestructuringErrors, sawUnary)
      if (_return.operator == "delete") {
        if (_return.argument.type == "MemberExpression" && _return.argument.property.type == "PrivateName") {
          this.raise(_return.start, "Private elements may not be deleted")
        }
      }
      return _return
    };

    return Parser_;
  }(Parser))
  Parser.prototype.privateNameToken = new acorn.TokenType("privateName")
  return Parser
}
